import { ModelService, Constants, Actor, Pawn, v3_multiply, mix, AM_Smoothed, v3_add, v3_floor, v3_min, v3_max, v3_sub, PM_Smoothed,
    PM_ThreeVisible, THREE, Behavior, AM_Behavioral, q_multiply, q_axisAngle, v3_normalize, q_normalize} from "@croquet/worldcore";

import { toWorld, packKey} from "./Voxels";

//------------------------------------------------------------------------------------------
//-- FallBehavior --------------------------------------------------------------------------
//------------------------------------------------------------------------------------------

export class FallBehavior extends Behavior {

    init(options) {
        super.init(options);
        const voxels = this.service("Voxels");
        this.bottom = voxels.solidBelow(...this.actor.voxel);
    }

    get velocity() { return this._velocity || 0}
    set velocity(v) { this._velocity = v}

    do(delta) {

        const gravity = Constants.gravity;
        this.velocity = this.velocity + gravity *  delta/1000;
        const fraction = this.actor.fraction;
        const z = fraction[2] - this.velocity/Constants.scaleZ;
        fraction[2] = z;
        this.actor.set({fraction});
        this.actor.clamp();
        if (this.actor.voxel[2] < this.bottom) {
            this.succeed();
            this.actor.destroy();
        }
    }

}
FallBehavior.register("FallBehavior");

//------------------------------------------------------------------------------------------
//-- SpinBehavior --------------------------------------------------------------------------
//------------------------------------------------------------------------------------------

class SpinBehavior extends Behavior {
    init(options) {
        super.init(options);
    }

    get axis() { return this._axis || v3_normalize([2,1,3])}
    get speed() { return this._speed || 1}

    do(delta) {
        let q = this.actor.rotation;
        q = q_multiply(q, q_axisAngle(this.axis, 0.13 * delta * this.speed / 50));
        q = q_normalize(q);
        this.actor.rotateTo(q);
    }
}
SpinBehavior.register("SpinBehavior");

//------------------------------------------------------------------------------------------
//-- VoxelActor ----------------------------------------------------------------------------
//------------------------------------------------------------------------------------------

export class VoxelActor extends mix(Actor).with(AM_Smoothed, AM_Behavioral) {

    init(options) {
        super.init(options);
        this.startBehavior(FallBehavior, {name: "fall"})
        // this.startBehavior(SpinBehavior, {name: "spin"})

        this.xxx = SpinBehavior;

        this.subscribe("input", "oDown", this.vvv);
    }

    vvv() {
        console.log(this.xxx);
        this.xxx = FallBehavior;
    }

    get pawn() {return VoxelPawn}

    voxelSet(v) { this._voxel = v; this.set({translation: toWorld(v3_add(v, this.fraction))})}
    fractionSet(v) { this._fraction = v; this.set({translation: toWorld(v3_add(v, this.voxel))})}

    get voxel() { return this._voxel || [0,0,0]}
    get key() { return packKey(...this.voxel)}
    get fraction() { return this._fraction || [0,0,0]}

    clamp() {
        const floor = v3_floor(this.fraction);
        const fraction = v3_sub(this.fraction, floor);
        const voxel = v3_add(this.voxel, floor);
        this.set({voxel,fraction});
    }

}
VoxelActor.register("VoxelActor");


//------------------------------------------------------------------------------------------
//-- VoxelPawn------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------


class VoxelPawn extends mix(Pawn).with(PM_Smoothed, PM_ThreeVisible) {
    constructor(actor) {
        super(actor);

        this.geometry = new THREE.BoxGeometry( 1, 1, 1 );
        this.geometry.translate(0,0,0.5)
        this.material = new THREE.MeshStandardMaterial( {color: new THREE.Color( 0xff0000 )} );

        this.material.side = THREE.DoubleSide;
        this.material.shadowSide = THREE.DoubleSide;
        this.mesh = new THREE.Mesh( this.geometry, this.material );
        this.mesh.receiveShadow = true;
        this.mesh.castShadow = true;
        this.setRenderObject(this.mesh);

    }
}