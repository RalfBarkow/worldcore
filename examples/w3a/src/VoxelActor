import { ModelService, Constants, Actor, Pawn, v3_multiply, mix, AM_Smoothed, v3_add, v3_floor, v3_min, v3_max, v3_sub, PM_Smoothed,
    PM_ThreeVisible, THREE, Behavior, AM_Behavioral, q_multiply, q_axisAngle, v3_normalize, q_normalize, CompositeBehavior, sphericalRandom, RegisterMixin} from "@croquet/worldcore";

import { toWorld, packKey} from "./Voxels";

//------------------------------------------------------------------------------------------
//-- HopBehavior ---------------------------------------------------------------------------
//------------------------------------------------------------------------------------------

export class HopBehavior extends Behavior {

    init(options) {
        super.init(options);
    }

    get velocity() { return this.actor._velocity || 0}
    set velocity(v) { this.actor._velocity = v}

    onStart() {
        this.velocity = -0.5;
        this.tickRate = 0;
    }

}
HopBehavior.register("HopBehavior");

//------------------------------------------------------------------------------------------
//-- FallBehavior --------------------------------------------------------------------------
//------------------------------------------------------------------------------------------

export class FallBehavior extends Behavior {

    init(options) {
        super.init(options);
        this.tickRate = 15;
        const voxels = this.service("Voxels");
        this.bottom = voxels.solidBelow(...this.actor.voxel);
    }

    get velocity() { return this.actor._velocity || 0}
    set velocity(v) { this.actor._velocity = v}

    do(delta) {
        const gravity = Constants.gravity/2;
        // const gravity = 0.1;
        this.velocity = this.velocity + gravity *  delta/1000;
        const fraction = this.actor.fraction;
        const z = fraction[2] - this.velocity/Constants.scaleZ;
        fraction[2] = z;
        this.actor.set({fraction});
        this.actor.clamp();
        if (this.actor.voxel[2] < this.bottom) {
            this.succeed();
            this.actor.destroy();
        }
    }

}
FallBehavior.register("FallBehavior");

//------------------------------------------------------------------------------------------
//-- SpinBehavior --------------------------------------------------------------------------
//------------------------------------------------------------------------------------------

class SpinBehavior extends Behavior {
    init(options) {
        super.init(options);
        this.tickRate = 15;
    }

    get axis() { return this._axis || sphericalRandom()}
    get speed() { return this._speed || 0.1 + this.random() * 0.9}

    do(delta) {
        let q = this.actor.rotation;
        q = q_multiply(q, q_axisAngle(this.axis, 0.13 * delta * this.speed / 1000));
        q = q_normalize(q);
        this.actor.rotateTo(q);
    }
}
SpinBehavior.register("SpinBehavior");

//------------------------------------------------------------------------------------------
//-- VoxelActor ----------------------------------------------------------------------------
//------------------------------------------------------------------------------------------

export class VoxelActor extends mix(Actor).with(AM_Smoothed, AM_Behavioral) {

    get pawn() {return VoxelPawn}

    init(options) {
        super.init(options);
        this.startBehavior({name: "SequenceBehavior", options: {parallel: true, behaviors:[
            {name: "HopBehavior"},
            {name: "FallBehavior"},
            {name: "SpinBehavior"}]
        }});
    }

    voxelSet(v) { this._voxel = v; this.set({translation: toWorld(v3_add(v, this.fraction))})}
    fractionSet(v) { this._fraction = v; this.set({translation: toWorld(v3_add(v, this.voxel))})}

    get voxel() { return this._voxel || [0,0,0]}
    get key() { return packKey(...this.voxel)}
    get fraction() { return this._fraction || [0,0,0]}

    clamp() {
        const floor = v3_floor(this.fraction);
        const fraction = v3_sub(this.fraction, floor);
        const voxel = v3_add(this.voxel, floor);
        this.set({voxel,fraction});
    }

}
VoxelActor.register("VoxelActor");


//------------------------------------------------------------------------------------------
//-- VoxelPawn------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------


class VoxelPawn extends mix(Pawn).with(PM_Smoothed, PM_ThreeVisible) {
    constructor(actor) {
        super(actor);

        this.geometry = new THREE.BoxGeometry( 1, 1, 1 );
        this.material = new THREE.MeshStandardMaterial( {color: new THREE.Color(...Constants.color.dirt)} );

        this.material.side = THREE.DoubleSide;
        this.material.shadowSide = THREE.DoubleSide;
        this.mesh = new THREE.Mesh( this.geometry, this.material );
        this.mesh.receiveShadow = true;
        this.mesh.castShadow = true;
        this.setRenderObject(this.mesh);

    }
}

